map function optimisation
=========================

Level 5 : the long journey to optimisation
==========================================

Now that we have our benchmark code factorized and running for std::vector and
std::list, we would like to see if there is some room for optimisations, without
changing the benchmarking code.

"Random access" container
-------------------------

An std::vector object can simply be viewed as a continuous buffer in memory.
Typically, such objects have these properties:

 * a pointer to this buffer
 * the size of the allocated memory
 * the size of the *actual* number of elements in this buffer (smaller than the
   previous)

When the `reserve' function is called, the buffer is grown to the given size,
but the number of actual elements in the buffer stays the same. The `push_back'
and `emplace_back' functions will change this size.

Thus, the previous code that we had, that is:

	Container ret;
	map_reserve(ret, c.size());
	for (auto const& v: c) {
		ret.emplace_back(std::move(f(v)));
	}

Actually does this (pseudo-code):

	Container ret;
	ret._size = 0;
    ret._buffer = malloc(c.size()*sizeof(T));
	ret._buffer_size = c.size();
	for (auto const& v: c) {
		ret._buffer[ret._size] = std::move(f(v));
		ret._size++;
	}

One can arguy that we could juste make one addition for the size, and simply do:


	Container ret;
	ret._size = 0;
    ret._buffer = malloc(c.size()*sizeof(T));
	ret._buffer_size = c.size();
	ret._size += c.size();
	for (size_t i = 0; i < c.size(); i++) {
		ret._buffer[i] = std::move(f(c[i]));
	}

In a more C++-ish way, this would give:

	Container ret;
	ret.resize(c.size());
	for (size_t i = 0; i < c.size(); i++) {
		ret[i] = std::move(f(c[i]));
	}
	return std::move(ret);

From there:

- Find out the differences between resize and reserve, and figure out why this
  would work.

- Change your map function with this code, and only compile your benchmark code
  for the std::vector class. Do you see any improvements?

- Compile with -O3 -march=native -mtune=native. Do you see any improvements?
  What just happened? (-ftree-vectorizer-verbose=1 might give you some hints
  ;))

- Use IDA to confirm your findings.

What whould be great is that, if we have a container that suppors it, the map
function would instantiate as the one we previously wrote. 

SFINAE back to the resuce !
---------------------------

We will use the SFINAE trick as in the previous level!

- Write a class that allows you to check whether a Container type has random access iterators

- Use SFINAE to specialise your map function

- Benchmark the whole thing :)
